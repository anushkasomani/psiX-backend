"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const helpers_1 = require("./helpers");
const trees_database_1 = require("./trees-database");
class CoreMMR extends trees_database_1.TreesDatabase {
    hasher;
    constructor(store, hasher, mmrUuid) {
        super(store, mmrUuid);
        this.hasher = hasher;
    }
    async append(value) {
        if (!this.hasher.isElementSizeValid(value))
            throw new Error("Element size is too big to hash with this hasher");
        const elementsCount = await this.elementsCount.get();
        const peaks = await this.retrievePeaksHashes((0, helpers_1.findPeaks)(elementsCount));
        let lastElementIdx = await this.elementsCount.increment();
        const leafIndex = lastElementIdx;
        const hash = this.hasher.hash([lastElementIdx.toString(), value]);
        await this.hashes.set(hash, lastElementIdx);
        peaks.push(hash);
        let height = 0;
        while ((0, helpers_1.getHeight)(lastElementIdx + 1) > height) {
            lastElementIdx++;
            const rightHash = peaks.pop();
            const leftHash = peaks.pop();
            const parentHash = this.hasher.hash([lastElementIdx.toString(), this.hasher.hash([leftHash, rightHash])]);
            await this.hashes.set(parentHash, lastElementIdx);
            peaks.push(parentHash);
            height++;
        }
        await this.elementsCount.set(lastElementIdx);
        const rootHash = await this.bagThePeaks();
        await this.rootHash.set(rootHash);
        const leaves = await this.leavesCount.increment();
        return {
            leavesCount: leaves,
            elementsCount: lastElementIdx,
            leafIndex,
            rootHash,
        };
    }
    async getProof(leafIndex, options = {}) {
        if (leafIndex < 1)
            throw new Error("Index must be greater than 1");
        const { elementsCount, formattingOpts } = options;
        const treeSize = elementsCount ?? (await this.elementsCount.get());
        if (leafIndex > treeSize)
            throw new Error("Index must be less than the tree tree size");
        const peaks = (0, helpers_1.findPeaks)(treeSize);
        const siblings = [];
        let index = leafIndex;
        while (!peaks.includes(index)) {
            const isRight = (0, helpers_1.getHeight)(index + 1) == (0, helpers_1.getHeight)(index) + 1;
            const sib = isRight ? index - (0, helpers_1.siblingOffset)((0, helpers_1.getHeight)(index)) : index + (0, helpers_1.siblingOffset)((0, helpers_1.getHeight)(index));
            siblings.push(sib);
            index = isRight ? index + 1 : index + (0, helpers_1.parentOffset)((0, helpers_1.getHeight)(index));
        }
        const peaksHashes = await this.retrievePeaksHashes(peaks, formattingOpts?.peaks);
        let siblingsHashes = [...(await this.hashes.getMany(siblings)).values()];
        if (options.formattingOpts) {
            const { proof: proofFormattingOpts } = options.formattingOpts;
            siblingsHashes = (0, types_1.formatProof)(siblingsHashes, proofFormattingOpts);
        }
        return {
            leafIndex: leafIndex,
            leafHash: await this.hashes.get(leafIndex),
            siblingsHashes,
            peaksHashes,
            elementsCount: treeSize,
        };
    }
    async getProofs(leavesIds, options = {}) {
        const { elementsCount, formattingOpts } = options;
        const treeSize = elementsCount ?? (await this.elementsCount.get());
        leavesIds.forEach((leafIndex) => {
            if (leafIndex < 1)
                throw new Error("Index must be greater than 1");
            if (leafIndex > treeSize)
                throw new Error("Index must be less than the tree tree size");
        });
        const peaks = (0, helpers_1.findPeaks)(treeSize);
        const siblingsPerLeaf = new Map();
        for (const leafIndex of leavesIds) {
            const siblings = [];
            let index = leafIndex;
            while (!peaks.includes(index)) {
                const isRight = (0, helpers_1.getHeight)(index + 1) == (0, helpers_1.getHeight)(index) + 1;
                const sib = isRight ? index - (0, helpers_1.siblingOffset)((0, helpers_1.getHeight)(index)) : index + (0, helpers_1.siblingOffset)((0, helpers_1.getHeight)(index));
                siblings.push(sib);
                index = isRight ? index + 1 : index + (0, helpers_1.parentOffset)((0, helpers_1.getHeight)(index));
            }
            siblingsPerLeaf.set(leafIndex, siblings);
        }
        const peaksHashes = await this.retrievePeaksHashes(peaks, formattingOpts?.peaks);
        const allSiblingsHashes = await this.hashes.getMany(Array.from(siblingsPerLeaf.values()).flat());
        const leafHashes = await this.hashes.getMany(leavesIds);
        const proofs = [];
        for (const leafIndex of leavesIds) {
            const siblings = siblingsPerLeaf.get(leafIndex);
            let siblingsHashes = [];
            for (const sibling of siblings) {
                siblingsHashes.push(allSiblingsHashes.get(sibling.toString()));
            }
            if (options.formattingOpts) {
                const { proof: proofFormattingOpts } = options.formattingOpts;
                siblingsHashes = (0, types_1.formatProof)(siblingsHashes, proofFormattingOpts);
            }
            proofs.push({
                leafIndex: leafIndex,
                leafHash: leafHashes.get(leafIndex.toString()),
                siblingsHashes,
                peaksHashes,
                elementsCount: treeSize,
            });
        }
        return proofs;
    }
    async verifyProof(proof, leafValue, options = {}) {
        const { elementsCount, formattingOpts } = options;
        const treeSize = elementsCount ?? (await this.elementsCount.get());
        if (formattingOpts) {
            const { proof: proofFormat, peaks: peaksFormat } = formattingOpts;
            const proofNullValuesCount = proof.siblingsHashes.filter((s) => s === proofFormat.nullValue).length;
            proof.siblingsHashes = proof.siblingsHashes.slice(0, proof.siblingsHashes.length - proofNullValuesCount);
            const peaksNullValuesCount = proof.peaksHashes.filter((s) => s === peaksFormat.nullValue).length;
            proof.peaksHashes = proof.peaksHashes.slice(0, proof.peaksHashes.length - peaksNullValuesCount);
        }
        let { leafIndex, siblingsHashes } = proof;
        if (leafIndex < 1)
            throw new Error("Index must be greater than 1");
        if (leafIndex > treeSize)
            throw new Error("Index must be in the tree");
        let hash = this.hasher.hash([leafIndex.toString(), leafValue]);
        for (const proofHash of siblingsHashes) {
            const isRight = (0, helpers_1.getHeight)(leafIndex + 1) == (0, helpers_1.getHeight)(leafIndex) + 1;
            leafIndex = isRight ? leafIndex + 1 : leafIndex + (0, helpers_1.parentOffset)((0, helpers_1.getHeight)(leafIndex));
            hash = this.hasher.hash([
                leafIndex.toString(),
                isRight ? this.hasher.hash([proofHash, hash]) : this.hasher.hash([hash, proofHash]),
            ]);
        }
        return (await this.retrievePeaksHashes((0, helpers_1.findPeaks)(treeSize))).includes(hash);
    }
    async getPeaks(options = {}) {
        const { elementsCount, formattingOpts } = options;
        const treeSize = elementsCount ?? (await this.elementsCount.get());
        const peaksIdxs = (0, helpers_1.findPeaks)(treeSize);
        const peaks = await this.retrievePeaksHashes(peaksIdxs);
        if (formattingOpts) {
            return (0, types_1.formatPeaks)(peaks, formattingOpts);
        }
        return peaks;
    }
    async bagThePeaks(elementsCount) {
        const treeSize = elementsCount ?? (await this.elementsCount.get());
        const peaksIdxs = (0, helpers_1.findPeaks)(treeSize);
        const peaksHashes = await this.retrievePeaksHashes(peaksIdxs);
        if (peaksIdxs.length === 0)
            return "0x0";
        else if (peaksIdxs.length === 1) {
            return this.hasher.hash([treeSize.toString(), peaksHashes[0]]);
        }
        const root0 = this.hasher.hash([peaksHashes[peaksHashes.length - 2], peaksHashes[peaksHashes.length - 1]]);
        const root = peaksHashes
            .slice(0, peaksHashes.length - 2)
            .reverse()
            .reduce((prev, cur) => this.hasher.hash([cur, prev]), root0);
        return this.hasher.hash([treeSize.toString(), root]);
    }
    async retrievePeaksHashes(peaksIdxs, formattingOpts) {
        const hashes = await this.hashes.getMany(peaksIdxs);
        if (formattingOpts) {
            return (0, types_1.formatPeaks)([...hashes.values()], formattingOpts);
        }
        return [...hashes.values()];
    }
    async clear() {
        const toDelete = [this.elementsCount.key, this.rootHash.key, this.leavesCount.key];
        const elementsCount = await this.elementsCount.get();
        return this.store.deleteMany(toDelete.concat(new Array(elementsCount).fill(0).map((_, i) => this.hashes.getFullKey(i + 1))));
    }
}
exports.default = CoreMMR;
//# sourceMappingURL=core.js.map