"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parentOffset = exports.siblingOffset = exports.getHeight = exports.peakMapHeight = exports.leadingZeros = exports.allOnes = exports.bitLength = exports.isPeak = exports.findPeaks = void 0;
const findPeaks = (elementsCount) => {
    if (elementsCount === 0)
        return [];
    if ((0, exports.getHeight)(elementsCount + 1) > (0, exports.getHeight)(elementsCount))
        return [];
    let top = 1;
    while (top - 1 <= elementsCount) {
        top <<= 1;
    }
    top = (top >> 1) - 1;
    if (top === 0) {
        return [1];
    }
    const peaks = [top];
    let peak = top;
    let outer = true;
    while (outer) {
        peak = bintreeJumpRightSibling(peak);
        while (peak > elementsCount) {
            peak = bintreeMoveDownLeft(peak);
            if (peak === 0) {
                outer = false;
                break;
            }
        }
        if (outer)
            peaks.push(peak);
    }
    return peaks;
};
exports.findPeaks = findPeaks;
const isPeak = (leafIndex, peaks) => peaks.indexOf(leafIndex) !== -1;
exports.isPeak = isPeak;
function bitLength(num) {
    return num.toString(2).length;
}
exports.bitLength = bitLength;
function allOnes(num) {
    return (1 << bitLength(num)) - 1 == num;
}
exports.allOnes = allOnes;
function leadingZeros(num) {
    return num === 0 ? 64 : 64 - bitLength(num);
}
exports.leadingZeros = leadingZeros;
function peakMapHeight(size) {
    if (size === 0) {
        return [0, 0];
    }
    let peak_size = BigInt("18446744073709551615") >> BigInt(leadingZeros(size));
    let peak_map = 0;
    while (peak_size != BigInt(0)) {
        peak_map <<= 1;
        if (size >= peak_size) {
            size -= Number(peak_size);
            peak_map |= 1;
        }
        peak_size >>= BigInt(1);
    }
    return [peak_map, size];
}
exports.peakMapHeight = peakMapHeight;
const getHeight = (elementIndex) => {
    let h = elementIndex;
    while (!allOnes(h)) {
        h = h - ((1 << (bitLength(h) - 1)) - 1);
    }
    return bitLength(h) - 1;
};
exports.getHeight = getHeight;
const siblingOffset = (height) => {
    return (0, exports.parentOffset)(height) - 1;
};
exports.siblingOffset = siblingOffset;
const parentOffset = (height) => {
    return 2 << height;
};
exports.parentOffset = parentOffset;
const bintreeJumpRightSibling = (elementIndex) => {
    const height = (0, exports.getHeight)(elementIndex);
    return elementIndex + (1 << (height + 1)) - 1;
};
const bintreeMoveDownLeft = (elementIndex) => {
    const height = (0, exports.getHeight)(elementIndex);
    if (height === 0) {
        return 0;
    }
    return elementIndex - (1 << height);
};
//# sourceMappingURL=helpers.js.map