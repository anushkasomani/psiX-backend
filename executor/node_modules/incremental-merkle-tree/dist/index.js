"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IncrementalMerkleTree = void 0;
const tree_database_1 = require("./tree-database");
class IncrementalMerkleTree extends tree_database_1.TreeDatabase {
    size;
    nullValue;
    hasher;
    constructor(size, nullValue, hasher, store, treeUuid) {
        super(store, treeUuid);
        this.size = size;
        this.nullValue = nullValue;
        this.hasher = hasher;
    }
    static async initialize(size, nullValue, hasher, store, treeUuid) {
        const tree = new IncrementalMerkleTree(size, nullValue, hasher, store, treeUuid);
        const nodes = tree.renderEmptyTree();
        await tree.nodes.setMany(nodes
            .flat()
            .reduce((acc, curr) => ({ ...acc, [`${curr.depth.toString()}:${curr.index.toString()}`]: curr.hash }), {}));
        await tree.rootHash.set(nodes[nodes.length - 1][0].hash);
        return tree;
    }
    async getRoot() {
        return this.rootHash.get();
    }
    async getInclusionMultiProof(indexesToProve) {
        const treeDepth = this.getTreeDepth();
        const leaves = [...indexesToProve].sort((a, b) => a - b);
        const proofLevels = [leaves.map((idx) => [idx, false])];
        for (let currDepth = treeDepth; currDepth > 0; currDepth--) {
            const currentLevel = proofLevels[proofLevels.length - 1];
            const nextLevel = [];
            for (const [currentNodeIdx] of currentLevel) {
                const childIdx = Math.floor(currentNodeIdx / 2);
                if (nextLevel.find(([i]) => i === childIdx))
                    continue;
                const isEven = currentNodeIdx % 2 === 0;
                const neighbourIdx = isEven ? currentNodeIdx + 1 : currentNodeIdx - 1;
                const isSatisfied = currentLevel.find(([idx]) => idx === neighbourIdx);
                if (!isSatisfied)
                    currentLevel.push([neighbourIdx, true]);
                nextLevel.push([childIdx, false]);
            }
            proofLevels.push(nextLevel);
        }
        const kvKeys = proofLevels
            .reduce((prev, level, i) => {
            const levelKV = level.reduce((prev, [idx, isNeeded]) => (isNeeded ? [...prev, `${treeDepth - i}:${idx}`] : prev), []);
            return levelKV.length ? [...prev, levelKV] : prev;
        }, [])
            .map((value, idx) => value.map((value) => [idx, value]))
            .flat();
        const nodes = (await this.nodes.getMany(kvKeys.map(([, key]) => key))).values();
        const multiproof = [];
        for (const [idx] of kvKeys) {
            if (!multiproof[idx])
                multiproof[idx] = [];
            multiproof[idx].push(nodes.next().value);
        }
        return multiproof;
    }
    async verifyMultiProof(indexes, values, proof) {
        const root = await this.rootHash.get();
        const calculatedRoot = this.calculateMultiproofRootHash(indexes, values, proof);
        return root == calculatedRoot;
    }
    calculateMultiproofRootHash(indexes, values, proof) {
        const newIndexes = [];
        const newValues = [];
        let level = [];
        while (indexes.length > 0) {
            const index = indexes.shift();
            const value = values.shift();
            const isEven = index % 2 === 0;
            const wantedIndex = isEven ? index + 1 : index - 1;
            const wantedValueI = indexes.findIndex((idx) => idx === wantedIndex);
            let wantedValue = null;
            if (wantedValueI === -1) {
                if (!level?.length)
                    level = proof.shift();
                wantedValue = level?.shift();
            }
            else {
                wantedValue = values.splice(wantedValueI, 1)[0];
                indexes.splice(wantedValueI, 1);
            }
            if (!wantedValue)
                return false;
            const hash = isEven ? this.hasher.hash([value, wantedValue]) : this.hasher.hash([wantedValue, value]);
            newIndexes.push(Math.floor(index / 2));
            newValues.push(hash);
        }
        if (proof.length > 0 || newIndexes.length > 1)
            return this.calculateMultiproofRootHash(newIndexes, newValues, proof);
        return newValues[0];
    }
    async getInclusionProof(index) {
        const requiredNodesByHeight = new Map();
        const treeDepth = this.getTreeDepth();
        let currentIndex = index;
        for (let i = treeDepth; i > 0; i--) {
            const isCurrentIndexEven = currentIndex % 2 === 0;
            const neighbour = isCurrentIndexEven ? currentIndex + 1 : currentIndex - 1;
            currentIndex = Math.floor(currentIndex / 2);
            requiredNodesByHeight.set(i, neighbour);
        }
        const kvEntries = [];
        for (const [height, index] of requiredNodesByHeight.entries()) {
            kvEntries.push(`${height}:${index}`);
        }
        const nodes = await this.nodes.getMany(kvEntries);
        return [...nodes.values()];
    }
    async verifyProof(index, value, proof) {
        let currentIndex = index;
        let currentValue = value;
        for (const p of proof) {
            const isCurrentIndexEven = currentIndex % 2 === 0;
            currentValue = isCurrentIndexEven ? this.hasher.hash([currentValue, p]) : this.hasher.hash([p, currentValue]);
            currentIndex = Math.floor(currentIndex / 2);
        }
        const root = await this.rootHash.get();
        return root == currentValue;
    }
    async update(index, oldValue, newValue, proof) {
        const isProofValid = await this.verifyProof(index, oldValue, proof);
        if (!isProofValid)
            throw new Error("Invalid proof");
        const kvUpdates = {};
        let currentIndex = index;
        let currentDepth = this.getTreeDepth();
        let currentValue = newValue;
        kvUpdates[`${currentDepth}:${currentIndex}`] = currentValue;
        for (const p of proof) {
            const isCurrentIndexEven = currentIndex % 2 === 0;
            currentValue = isCurrentIndexEven ? this.hasher.hash([currentValue, p]) : this.hasher.hash([p, currentValue]);
            currentDepth--;
            currentIndex = Math.floor(currentIndex / 2);
            if (currentDepth === 0)
                break;
            kvUpdates[`${currentDepth}:${currentIndex}`] = currentValue;
        }
        await this.nodes.setMany(kvUpdates);
        await this.rootHash.set(currentValue);
        return currentValue;
    }
    getTreeDepth() {
        return Math.ceil(Math.log2(this.size));
    }
    renderEmptyTree() {
        let currentHeightNodesCount = this.size;
        let currentDepth = this.getTreeDepth();
        const tree = [
            new Array(this.size).fill(0).map((_, index) => ({ hash: this.nullValue, index: index, depth: currentDepth })),
        ];
        while (currentHeightNodesCount > 1) {
            currentDepth--;
            const currentHeightNodes = tree[tree.length - 1];
            const nextHeightNodes = [];
            for (let i = 0; i < currentHeightNodesCount; i += 2) {
                const leftSibling = currentHeightNodes[i].hash;
                const rightSibling = currentHeightNodes[i + 1]?.hash ?? this.nullValue;
                const node = {
                    hash: this.hasher.hash([leftSibling, rightSibling]),
                    index: Math.floor(i / 2),
                    depth: currentDepth,
                };
                nextHeightNodes.push(node);
            }
            tree.push(nextHeightNodes);
            currentHeightNodesCount = nextHeightNodes.length;
        }
        return tree;
    }
}
exports.IncrementalMerkleTree = IncrementalMerkleTree;
//# sourceMappingURL=index.js.map